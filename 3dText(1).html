<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG to 3D - XY Movement (Drag & Undo)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #controlsPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.65);
            color: white;
            border-radius: 5px;
            z-index: 100;
            max-width: 280px;
        }
        label { margin-right: 5px; display: inline-block; min-width: 100px; font-size: 0.9em;}
        input[type="number"] { width: 60px; margin-right: 10px; margin-bottom: 5px; padding: 3px;}
        input[type="file"] { margin-bottom: 10px; }
        .input-group { margin-bottom: 8px; }
        hr { border-color: #555; margin: 12px 0;}
        h4 { margin-top: 0; margin-bottom: 8px; border-bottom: 1px solid #555; padding-bottom: 4px;}
    </style>
</head>
<body>

    <div id="controlsPanel">
        <h4>SVG Import & Extrude</h4>
        <div class="input-group">
            <label for="svgFile">Import SVG:</label>
            <input type="file" id="svgFile" accept=".svg">
        </div>
        <div class="input-group">
            <label for="extrudeDepth">Extrude Depth:</label>
            <input type="number" id="extrudeDepth" value="10" min="1" step="1">
        </div>
        <div class="input-group">
            <label for="bevelThickness">Bevel Thick:</label>
            <input type="number" id="bevelThickness" value="1" min="0" step="0.1">
        </div>
        <div class="input-group">
            <label for="bevelSize">Bevel Size:</label>
            <input type="number" id="bevelSize" value="0.5" min="0" step="0.1">
        </div>
        <hr>
        <h4>Selected Object Position (XY Plane)</h4>
        <div class="input-group">
            <label for="posX">Position X:</label>
            <input type="number" id="posX" value="" step="1" placeholder="N/A">
        </div>
        <div class="input-group">
            <label for="posY">Position Y:</label>
            <input type="number" id="posY" value="" step="1" placeholder="N/A">
        </div>
        <div class="input-group">
            <label for="posZ">Position Z (Locked):</label>
            <input type="number" id="posZ" value="" step="1" placeholder="N/A" disabled>
        </div>
         <small>Click object to select. Drag selected object to move on XY plane. Ctrl+Z to undo. Click empty space to deselect.</small>
    </div>

    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/SVGLoader.js"></script>

    <script>
        let scene, camera, renderer, orbitControls;
        let loadedObjectGroups = [];
        let raycaster;
        let mouse;

        let selectedObject = null;
        let isDragging = false;
        const dragPlane = new THREE.Plane();
        const dragOffset = new THREE.Vector3();
        const dragIntersection = new THREE.Vector3();
        const Z_AXIS = new THREE.Vector3(0, 0, 1);

        // Undo functionality
        let undoHistory = [];
        const MAX_UNDO_STEPS = 20;

        const extrudeDepthInput = document.getElementById('extrudeDepth');
        const bevelThicknessInput = document.getElementById('bevelThickness');
        const bevelSizeInput = document.getElementById('bevelSize');
        const posXInput = document.getElementById('posX');
        const posYInput = document.getElementById('posY');
        const posZInput = document.getElementById('posZ');

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 70, 150);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(15, 30, 20);
            scene.add(directionalLight1);

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.target.set(0,0,0);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            document.getElementById('svgFile').addEventListener('change', handleFileSelect, false);
            window.addEventListener('resize', onWindowResize, false);
            
            renderer.domElement.addEventListener('pointerdown', onDocumentPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onDocumentPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onDocumentPointerUp, false);
            window.addEventListener('keydown', handleKeyDown); // For Undo

            [extrudeDepthInput, bevelThicknessInput, bevelSizeInput].forEach(input => {
                input.addEventListener('change', () => {
                    const fileInput = document.getElementById('svgFile');
                    if (fileInput.files && fileInput.files[0] && loadedObjectGroups.length > 0) {
                        handleFileSelect({ target: { files: [fileInput.files[0]] } });
                    }
                });
            });

            [posXInput, posYInput].forEach(input => {
                input.addEventListener('change', handlePositionInputChange);
            });

            // const gridHelper = new THREE.GridHelper(200, 20, 0x666666, 0x444444);
            // scene.add(gridHelper);
            // const axesHelper = new THREE.AxesHelper(30);
            // scene.add(axesHelper);

            animate();
        }

        function addUndoState(object, position) {
            if (!object) return;
            if (undoHistory.length >= MAX_UNDO_STEPS) {
                undoHistory.shift(); // Remove the oldest state
            }
            undoHistory.push({ object: object, position: position.clone() });
            // console.log("Undo state added. History size:", undoHistory.length);
        }

        function clearUndoHistory() {
            undoHistory = [];
            // console.log("Undo history cleared.");
        }

        function handleKeyDown(event) {
            if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'z') {
                event.preventDefault();
                if (undoHistory.length > 0) {
                    const lastState = undoHistory.pop();
                    if (lastState && lastState.object) {
                        // Check if the object is still part of the scene (might have been removed by new SVG load)
                        let stillInScene = false;
                        loadedObjectGroups.forEach(group => {
                            if (group === lastState.object || (group.children && group.children.includes(lastState.object))) {
                                stillInScene = true;
                            }
                        });
                        
                        if (stillInScene) {
                            lastState.object.position.copy(lastState.position);
                            selectedObject = lastState.object; // Re-select the object that was undone
                            updatePositionInputsUI(selectedObject);
                            // console.log("Undo applied to:", selectedObject.name);
                        } else {
                             // console.log("Undo failed: Object no longer in scene.");
                             // Try again if there are more states, in case this was an edge case
                             if(undoHistory.length > 0) handleKeyDown(event);
                        }
                    }
                } else {
                    // console.log("Undo history empty.");
                }
            }
        }


        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === "image/svg+xml") {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const svgData = e.target.result;
                    loadSVG(svgData);
                };
                reader.readAsText(file);
            } else {
                alert("Please select a valid SVG file.");
            }
        }

        function onDocumentPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(loadedObjectGroups, true);

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                let hitGroup = intersectedMesh;
                while (hitGroup.parent && !loadedObjectGroups.includes(hitGroup) && hitGroup.parent !== scene) {
                    hitGroup = hitGroup.parent;
                }

                if (hitGroup && loadedObjectGroups.includes(hitGroup)) {
                    if (selectedObject !== hitGroup) { // If selecting a new object or first object
                         // Don't add undo state if just re-clicking the same object before dragging
                    }
                    selectedObject = hitGroup;
                    addUndoState(selectedObject, selectedObject.position); // Add state *before* drag starts
                    isDragging = true;
                    orbitControls.enabled = false;

                    dragPlane.setFromNormalAndCoplanarPoint(Z_AXIS, selectedObject.position);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                        dragOffset.copy(selectedObject.position).sub(dragIntersection);
                    }
                    updatePositionInputsUI(selectedObject);
                }
            } else { 
                if (selectedObject) {
                    // Don't deselect if currently dragging, wait for pointerup
                    if (!isDragging) {
                        selectedObject = null;
                        updatePositionInputsUI(null);
                    }
                }
            }
        }

        function onDocumentPointerMove(event) {
            if (isDragging && selectedObject) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                if (raycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                    const newPos = dragIntersection.add(dragOffset);
                    selectedObject.position.set(newPos.x, newPos.y, selectedObject.position.z);
                    updatePositionInputsUI(selectedObject);
                }
            }
        }

        function onDocumentPointerUp(event) {
            if (isDragging) {
                isDragging = false;
                orbitControls.enabled = true;
                // The undo state was added on pointerDown
            }
        }

        function handlePositionInputChange() {
            if (selectedObject) {
                addUndoState(selectedObject, selectedObject.position); // Add state *before* input change
                const x = parseFloat(posXInput.value);
                const y = parseFloat(posYInput.value);
                const z = selectedObject.position.z; 

                if (!isNaN(x) && !isNaN(y)) {
                     selectedObject.position.set(x, y, z);
                     updatePositionInputsUI(selectedObject);
                }
            }
        }
        
        function updatePositionInputsUI(object) {
            if (object) {
                posXInput.value = object.position.x.toFixed(2);
                posYInput.value = object.position.y.toFixed(2);
                posZInput.value = object.position.z.toFixed(2);
                posXInput.placeholder = "0.00"; 
                posYInput.placeholder = "0.00";
                posZInput.placeholder = object.position.z.toFixed(2);
            } else {
                posXInput.value = ""; posYInput.value = ""; posZInput.value = "";
                posXInput.placeholder = "N/A"; posYInput.placeholder = "N/A"; posZInput.placeholder = "N/A";
            }
        }

        function loadSVG(svgData) {
            clearUndoHistory();
            if (selectedObject) {
                selectedObject = null;
            }
            isDragging = false;
            orbitControls.enabled = true;

            loadedObjectGroups.forEach(group => {
                scene.remove(group);
                group.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose());
                            else child.material.dispose();
                        }
                    }
                });
            });
            loadedObjectGroups = [];
            updatePositionInputsUI(null);

            const loader = new THREE.SVGLoader();
            const data = loader.parse(svgData);

            const extrudeSettings = {
                depth: parseFloat(extrudeDepthInput.value) || 10,
                bevelEnabled: true,
                bevelThickness: parseFloat(bevelThicknessInput.value) || 1,
                bevelSize: parseFloat(bevelSizeInput.value) || 0.5,
                bevelOffset: 0,
                bevelSegments: 3
            };

            data.paths.forEach((pathData, index) => {
                const elementGroup = new THREE.Group();
                elementGroup.name = `SVG_Element_${index}`;

                const shapes = THREE.SVGLoader.createShapes(pathData);
                shapes.forEach((shape) => {
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    geometry.center(); // Center the individual mesh geometry

                    let fillColor = 0xffff00;
                    if (pathData.userData && pathData.userData.style &&
                        pathData.userData.style.fill && pathData.userData.style.fill !== 'none') {
                        try {
                            fillColor = new THREE.Color(pathData.userData.style.fill).getHex();
                        } catch (e) { /* ignore */ }
                    }
                    const material = new THREE.MeshStandardMaterial({
                        color: fillColor, metalness: 0.2, roughness: 0.7, side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.name = `Mesh_${index}`;
                    elementGroup.add(mesh);
                });

                if (elementGroup.children.length > 0) {
                    // Initial scaling
                    elementGroup.updateMatrixWorld(true);
                    const initialBox = new THREE.Box3().setFromObject(elementGroup);
                    const initialSize = new THREE.Vector3();
                    initialBox.getSize(initialSize);

                    const desiredElementSize = 20;
                    const maxDimXY = Math.max(initialSize.x, initialSize.y);
                    let scaleFactor = 1;
                    if (maxDimXY > 0.001) {
                        scaleFactor = desiredElementSize / maxDimXY;
                        elementGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    }

                    // FIX: Apply both X and Y rotations to correct orientation
                    elementGroup.rotation.x = Math.PI; // Corrects vertical flip
                    elementGroup.rotation.y = 0; // Corrects horizontal mirror

                    // Update matrix after scaling and rotation before centering the group
                    elementGroup.updateMatrixWorld(true);
                    const finalBox = new THREE.Box3().setFromObject(elementGroup);
                    const finalCenter = new THREE.Vector3();
                    finalBox.getCenter(finalCenter);

                    // Center the group itself at the origin
                    elementGroup.position.sub(finalCenter);
                    elementGroup.updateMatrixWorld(true); // Update again after position change

                    // Place object's bottom on the Y=0 plane (grid)
                    const adjustedBox = new THREE.Box3().setFromObject(elementGroup);
                    // elementGroup.position.y is already set by .sub(finalCenter)
                    // We want to adjust it so that adjustedBox.min.y becomes 0
                    elementGroup.position.y += (0 - adjustedBox.min.y);

                    scene.add(elementGroup);
                    loadedObjectGroups.push(elementGroup);
                }
            });

            // Layout loaded groups (unchanged from your code, but ensure matrices are updated)
            if (loadedObjectGroups.length > 0) {
                const BoundingBox = new THREE.Box3();
                let currentXOffset = 0;
                const spacing = 15;

                let totalArrangementWidth = 0;
                loadedObjectGroups.forEach(group => {
                    group.updateMatrixWorld(true); // Ensure matrix is up-to-date for bounding box
                    BoundingBox.setFromObject(group);
                    totalArrangementWidth += (BoundingBox.max.x - BoundingBox.min.x);
                });
                totalArrangementWidth += (spacing * (loadedObjectGroups.length - 1));

                const startX = -totalArrangementWidth / 2;
                currentXOffset = startX;

                loadedObjectGroups.forEach(group => {
                    group.updateMatrixWorld(true); // Ensure matrix is up-to-date
                    BoundingBox.setFromObject(group);
                    const objectWidth = BoundingBox.max.x - BoundingBox.min.x;
                    // Y position is already set to sit on the grid.
                    // Z position should be effectively 0 for each group due to centering.
                    group.position.x = currentXOffset + objectWidth / 2;
                    // group.position.z = 0; // Might be useful to explicitly ensure Z is 0 if issues persist
                    currentXOffset += objectWidth + spacing;
                });
            }

            if (loadedObjectGroups.length === 1) {
                const singleGroup = loadedObjectGroups[0];
                singleGroup.updateMatrixWorld(true); // Ensure matrix is up-to-date
                // Center single object at X=0, Z=0. Y is already handled.
                singleGroup.position.x = 0;
                // singleGroup.position.z = 0; // Ensure Z is reset if it was altered by centering logic for multiple objects
            }

            console.log(`SVG loaded. ${loadedObjectGroups.length} distinct element group(s) created.`);
            orbitControls.update();
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>